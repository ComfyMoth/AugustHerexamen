# Unit Testing
Een unit test is een stuk code (meestal een methode), die een ander stuk code aanroept en de juistheid van bepaalde veronderstellingen daarna controleert. Als de aannames verkeerd blijken te zijn is de unit test mislukt. 
een unit test zal zich richten op een specifieke stukje code en zoveel mogelijk afhankelijkheden buiten beschouwing laten. Zo zal je in een unit test vb. niet afhankelijk willen zijn van een extern systeem, een database, een netwerkverbinding, bestande op een schijf, enz
Als je deze afhankelijkheden ook wil testen spreken we over een intergration test.

## Eigenschappen van een goede unit test
- Hij moet geatomiseerd worden en herhaalbaar zijn
- hij moet eenvoudig te implementeren zijn
- Hij moet morgen nog relevant zijn
- Iedereen moet in staat zijn om de test met één druk op de knop uit te voeren
- Hij moet snel draaien
- Hij moet consequent zijn in resultaten (steeds hetzelfde resultaat)
- Hij moet volledig worden geïsoleerd (werkt onafhankelijk van andere tests)
- Als de test faalt moet het duidelijk zijn wat er misloopt en hoe je het probleem kan oplossen.
**Een unittest die aan deze eigenschappen voldoet doet ook meteen dienst als documentatie**

## Welke tests schrijven en wanneer zijn er voldoende
**ZOMBIES** kunnen van pas komen om te bepalen welke tests te schrijven, in welke volgorde, en wanneer je klaar bent met testen.

Dit acroniem bestaat uit een paar verschillende delen. 
Langs de ene kant beschrijft **ZOM** welke test scenario's toe te voegen, beginnend bij heel eenvoudige scenario's en erna complexerie.
**BIE** langs de andere kant beschrijft de dingen waarmee je rekening dient te houden bij het schrijven van de tests
De **S** is een verwijzing naar de eigenschap van een goede unittest dat hij eenvoudig moet zijn
![](https://apwt.gitbook.io/~gitbook/image?url=https%3A%2F%2Fblog.wingman-sw.com%2Ffiles%2Fimg%2Fzombies-2D.png&width=768&dpr=4&quality=100&sign=ae2d7d3&sv=1)

Neem als voorbeeld een Queue, dit is een data structuur die werkt zoals een wachtrij aan vb. de kassa in een winkel. Wie al het langst in de rij staat komt als eerste aan de beurt, en wie toekomt moet achteraan aansluiten. Dit principe wordt FIFO (First-In First-Out) genoemd. Als we hiervoor unittests moeten schrijven kunnen we als volgt te werk gaan.

De **Zero** tests zijn in dit geval unittests die het gedrag van een pas gemaakte Queue testen.
- Test 1: Het is mogelijk om een Queue aan te maken
- Test 2: Een nieuw aangemaakte Queue is leeg (`Count` functie returns 0)

De volgende stap zijn de **One** tests
- Test 3: De Queue is niet aanleg na een `Put` (`Count` functie returns 1) (**Boundary condition** overgang van 0 naar 1 element)
- Test 4: Het element dat `Get` returns is hetzelfde als wat er met `Put` in de Queue geplaatst is
- Test 5: als je eerst een `Put` doet en dan een `Get`, dan is de Queue terug leeg (`Count` functie returns 0) (**Boundary condition** overgang van 1 naar 0 elementen)

Dan volgen de **Many / More Complex** testen
- Test 6: Als je meerdere malen `Put` aanroept, dan geeft `Count` de juiste waarde (vb. 3x `Put` -> `Count` is 3)
- Test 7: Als je meerdere malen `Put` doet en erna `Get`, dan geeft `Get` het element van de eerste `Put`
- Test 8: Als je meerdere malen `Put` en `Get` doet, dan geeft `Count` de juiste waarde (vb. 3x `Put`, 2x `Get` -> `Count` is 1)
- Test 9: Als je meerdere malen `Put` en `Get` doet, dan geeft `Get` de juiste elementen (vb. `Put` 1, `Put` 2, `Put` 3 -> Eerste `Get` geeft 1, tweede `Get` geeft 2 en derde `Get` geeft 3 terug)
- Test 10: Als je `Get` doet op een lege queue treedt er een `Exception` op (**Exercise Exceptions**)

**Exercise Interfaces** komt in elk van deze tests aan bod. De volledige interface van de Queue (Put, Get, Count) wordt getest. Elke unittest test maar 1 specifiek scenario, dus ook aan **Simple Scenarios** is er voldaan.

## Een eerste test
Visual Studio 2022 voorziet tools om unit tests te maken en deze te automatiseren. We bouwen in ekele stappen een kleine console applicatie in Visual Studio 2022 en maken hier een unit test voor:

1. Maak in Visual Studio een nieuwe console applicatie aan met de naam `UnitTesting`
2. Voeg aan deze applicatie een nieuwe klasse toe met de naam `Calculator`ù
![[Pasted image 20240729153948.png]]
![[Pasted image 20240729154050.png]]
![[Pasted image 20240729154228.png]]

3. We voegen in deze klasse onderstaande methode toe

```cs
namespace UnitTesting 
{
	public class Calculator
	{
		public int Sum(int a, int b)
		{
		return 0;
		}
	}
}
```

4. Deze methode zullen we gebruiken om 2 getallen op te tellen. Zoals je kan zien is deze methode nog niet uitgewerkt en geeft deze steeds 0 terug. Voorlopig laten we dit zo. We zullen eerst een test maken voor deze methode. Deze test zal falen. Daarna implementeren we de juiste logica in deze methoden en laten we de test opnieuw lopen. Deze zal nu wel correct lopen. Deze manier van werken waarbij we eerst de test maken en dan pas de logica implemnteren noemen we `Test Driven Development` of `TDD`.
5. Klik nu met je rechter muisknop op je solution en klik op `Add > New Project`
6. Selecteer `MSTest Test project` (.NET Core) en klik op `Next`, kies als project naam `UnitTesting.Tests` en klik op `Create` (of klik Next, selecteer .NET 6.0 en klik op Create indien nodig)
![[Pasted image 20240730124549.png]]
7. Het `UnitTesting.Tests` project refereert naar klassen uit het project `UnitTesting`. We leggen dat vast in de dependencies. Klik rechts op `Dependencies`, kies `Project Reference` en selecteer `UnitTesting`.
![[Pasted image 20240730124947.png]]
